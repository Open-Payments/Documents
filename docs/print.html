<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Open Payments - Payment Processing Engine for Modern Financial Systems</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Components</li><li class="chapter-item expanded "><a href="message-processor/index.html"><strong aria-hidden="true">1.</strong> Message Processor</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message-processor/working-principle.html"><strong aria-hidden="true">1.1.</strong> How the Product Works</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="message-processor/workflow-processor.html"><strong aria-hidden="true">1.1.1.</strong> Workflow Processor</a></li><li class="chapter-item expanded "><a href="message-processor/workflow-definition.html"><strong aria-hidden="true">1.1.2.</strong> Workflow Definition</a></li><li class="chapter-item expanded "><a href="message-processor/tech-components.html"><strong aria-hidden="true">1.1.3.</strong> Technical Components</a></li><li class="chapter-item expanded "><a href="message-processor/message-structure.html"><strong aria-hidden="true">1.1.4.</strong> Message structure</a></li></ol></li><li class="chapter-item expanded "><a href="message-processor/auditing.html"><strong aria-hidden="true">1.2.</strong> Error Handling and Auditing Details</a></li><li class="chapter-item expanded "><a href="message-processor/core-strengths.html"><strong aria-hidden="true">1.3.</strong> Core Strengths</a></li></ol></li><li class="chapter-item expanded "><a href="messages-library/index.html"><strong aria-hidden="true">2.</strong> Messages Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="messages-library/installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="messages-library/usage.html"><strong aria-hidden="true">2.2.</strong> Usage</a></li></ol></li><li class="chapter-item expanded "><a href="messages-api/index.html"><strong aria-hidden="true">3.</strong> Messages API</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="messages-api/installation.html"><strong aria-hidden="true">3.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="messages-api/usage.html"><strong aria-hidden="true">3.2.</strong> Usage</a></li></ol></li><li class="chapter-item expanded "><a href="transformation/index.html"><strong aria-hidden="true">4.</strong> Message Transformation Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="transformation/installation.html"><strong aria-hidden="true">4.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="transformation/usage.html"><strong aria-hidden="true">4.2.</strong> Usage</a></li></ol></li><li class="chapter-item expanded "><a href="samplify/index.html"><strong aria-hidden="true">5.</strong> Samplify Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="samplify/installation.html"><strong aria-hidden="true">5.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="samplify/usage.html"><strong aria-hidden="true">5.2.</strong> Usage</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="contributions.html">Contributions</a></li><li class="chapter-item expanded affix "><a href="license.html">License</a></li><li class="chapter-item expanded affix "><a href="contactus.html">Contact Us</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Open Payments - Payment Processing Engine for Modern Financial Systems</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p align="center">
  <img src="./assets/profile-pic.png"  alt="Open Payments" width="128"/>
</p>
<h1 id="open-payments"><a class="header" href="#open-payments"><p style="text-align:center;">Open Payments</p></a></h1>
<p><strong>Open Payments</strong> is an open-source initiative focused on building a comprehensive toolkit for creating a modern, scalable, and efficient payment processing engine for banks and financial institutions. Our vision is to streamline financial messaging, facilitate interoperability across diverse financial ecosystems, and enable innovation within the payment industry. Open Payments provides robust, open-source components that make it easier for developers and institutions to implement secure and high-performance payment solutions.</p>
<h2 id="what-we-offer"><a class="header" href="#what-we-offer">What We Offer</a></h2>
<ul>
<li>
<p><strong><a href="./message-processor/">Message Processor</a></strong>: A powerful orchestration engine that manages and processes financial messages. It enables the seamless execution of payment workflows, from data enrichment and validation to transformation and routing, across multiple systems and services.</p>
</li>
<li>
<p><strong><a href="./messages-library/">Messages Library</a></strong>: A feature-rich library designed to handle the intricacies of financial messaging. Our library supports parsing, validating, transforming, and generating financial messages, with current support for widely used formats such as ISO 20022 and FedNow.</p>
</li>
<li>
<p><strong><a href="./messages-api/">Messages API</a></strong>: A RESTful API that exposes the capabilities of the Messages Library to external systems. With endpoints for message validation, transformation, and sample generation, it enables seamless integration with existing infrastructures.</p>
</li>
<li>
<p><strong><a href="./transformation/">Message Transformation Library</a></strong>: A versatile library that facilitates the transformation of message formats. Using powerful, configurable transformations, it enables seamless interoperability between different message standards and systems.</p>
</li>
<li>
<p><strong><a href="./samplify/">Samplify Library</a></strong>: Generate realistic, valid sample messages tailored for testing and development. This tool is invaluable for QA engineers, developers, and testing environments, offering flexibility to customize samples per unique testing requirements.</p>
</li>
</ul>
<h2 id="why-choose-open-payments"><a class="header" href="#why-choose-open-payments">Why Choose Open Payments?</a></h2>
<p>Open Payments offers a robust, developer-friendly framework for payment processing. Our open-source foundation empowers users to extend and customize the solution, whether for new formats, integration with emerging technologies, or unique compliance needs. We emphasize adaptability, reliability, and transparency, enabling financial institutions to leverage a community-driven approach to innovation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-processor"><a class="header" href="#message-processor">Message Processor</a></h1>
<p>The Message Processor is the core engine of the Open Payments platform, orchestrating payment transactions seamlessly from initiation to completion. It streamlines the flow of financial messages by ensuring each message is:</p>
<ul>
<li><strong>Enriched</strong>: Adds necessary information such as customer verification data and compliance checks.</li>
<li><strong>Validated</strong>: Confirms accuracy and compliance with regulatory and business rules.</li>
<li><strong>Transformed</strong>: Adjusts message formats to meet internal or external standards.</li>
<li><strong>Routed</strong>: Directs messages to appropriate systems or networks based on configurable workflows.</li>
</ul>
<p>By efficiently handling inbound messages, applying necessary transformations, and directing them to designated outbound channels, the Message Processor enables seamless integration with a bank’s existing systems. Its support for complex, multi-step workflows allows it to adapt to diverse payment formats and regulatory requirements, enhancing interoperability and operational efficiency.</p>
<h2 id="use-case-1-fednow-customer-credit-transfer-flow"><a class="header" href="#use-case-1-fednow-customer-credit-transfer-flow">Use Case #1: FedNow Customer Credit Transfer Flow</a></h2>
<p>In this use case, the Message Processor manages a real-time FedNow Customer Credit Transfer, overseeing each stage from initiation by the sender’s bank to final settlement at the clearing house.</p>
<ul>
<li><strong>Initiation</strong>: The sender’s bank initiates a credit transfer request formatted according to FedNow specifications. This message is sent to the Message Processor’s inbound channel.</li>
<li><strong>Enrichment</strong>: Upon receiving the message, the Message Processor enriches it by verifying customer details, checking the availability of funds, and applying regulatory compliance checks through configured enrichment connectors.</li>
<li><strong>Workflow Processing</strong>: The message is processed based on predefined rules within the workflow configuration. The Message Processor validates the message format and applies any necessary transformations to align with internal standards.</li>
<li><strong>Clearing and Settlement</strong>: After processing, the Message Processor routes the message through the outbound connection to the clearing house for final settlement.</li>
</ul>
<p>This flow demonstrates how the Message Processor ensures secure, compliant, and efficient processing of FedNow transactions, streamlining payment processes across financial institutions.</p>
<h2 id="use-case-2-embedded-preprocessor-for-payment-processing"><a class="header" href="#use-case-2-embedded-preprocessor-for-payment-processing">Use Case #2: Embedded Preprocessor for Payment Processing</a></h2>
<p>In this scenario, the Message Processor functions as an embedded preprocessor within a financial institution’s internal payment system, managing transactions in real-time before they reach the core banking system.</p>
<ul>
<li><strong>Transaction Intake</strong>: Incoming payment requests from various channels (e.g., mobile apps, web portals) are received by the embedded preprocessor.</li>
<li><strong>Initial Screening and Enrichment</strong>: The Message Processor performs initial validations and enrichment, such as Know Your Customer (KYC) checks, anti-fraud assessments, and data standardization.</li>
<li><strong>Processing</strong>: Based on preconfigured workflows, the Message Processor validates the message format, applies business rules, and prepares it for core processing. This may include formatting transformations to meet internal standards.</li>
<li><strong>Routing to Core System</strong>: Once validated and transformed, the message is routed to the core banking system for final processing and settlement.</li>
</ul>
<p>This use case highlights the Message Processor’s role as a seamless, embedded component in payment preprocessing, enabling faster, more secure payment handling while reducing the load on core systems.</p>
<h2 id="expanding-capabilities"><a class="header" href="#expanding-capabilities">Expanding Capabilities</a></h2>
<p>The Message Processor is a versatile solution that extends beyond these examples. It is designed to operate within any ecosystem where messages need to pass through multiple systems before reaching their destination. Whether in payment processing, regulatory compliance checks, or cross-system data integration, the Message Processor offers a flexible and reliable foundation for orchestrating complex workflows. It enhances efficiency and ensures seamless interoperability across various platforms, adapting to the evolving needs of financial institutions.</p>
<p>By integrating the Message Processor into your payment infrastructure, you can achieve greater operational efficiency, compliance, and adaptability, positioning your institution at the forefront of modern payment processing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-the-product-works"><a class="header" href="#how-the-product-works">How the Product Works</a></h1>
<p>The Message Processor operates through a streamlined workflow that orchestrates the processing of payment messages from reception to dispatch. Here’s a step-by-step explanation of how the system functions:</p>
<p><img src="message-processor/../assets/product-architecture.jpeg" alt="Message Processor working principle" /></p>
<h3 id="inbound-connection"><a class="header" href="#inbound-connection">Inbound Connection</a></h3>
<ul>
<li><strong>Message Reception</strong>: A new payment message is received from the inbound connection. This could be from various sources such as bank APIs, financial gateways, or other external systems.</li>
<li><strong>Queue Placement</strong>: The received message is placed into an inbound queue, making it ready for processing.</li>
</ul>
<h3 id="workflow-processor"><a class="header" href="#workflow-processor">Workflow Processor</a></h3>
<ul>
<li><strong>Message Retrieval</strong>: The Workflow Processor pulls the message from the inbound queue.</li>
<li><strong>Workflow Matching</strong>: It matches the message to the appropriate workflow based on predefined criteria such as payment type, originator, region, and other relevant fields.</li>
<li><strong>Workflow Definition</strong>: The selected workflow outlines the specific steps required to process the payment, tailored to the message’s attributes.</li>
</ul>
<h3 id="workflow-execution"><a class="header" href="#workflow-execution">Workflow Execution</a></h3>
<ul>
<li><strong>Enrichment</strong>: The system enriches the message by adding necessary customer data, account details, or other relevant information. This is often done by interacting with <strong>Enrichment Connectors</strong> that fetch data from external databases or services.</li>
<li><strong>Validation</strong>: The message undergoes validation checks to ensure accuracy, completeness, and compliance with regulatory and business rules.</li>
<li><strong>Transformation</strong>: The message is transformed into the required format (e.g., ISO 20022, SWIFT MT), supporting various industry standards to meet internal specifications or the requirements of the outbound systems.</li>
<li><strong>Step Completion</strong>: Each step in the workflow is executed sequentially, ensuring that the message is fully prepared for dispatch.</li>
</ul>
<h3 id="error-handling-and-logging"><a class="header" href="#error-handling-and-logging">Error Handling and Logging</a></h3>
<ul>
<li><strong>Error Detection</strong>: If any errors occur during processing—such as validation failures or issues in data enrichment—the system detects them immediately.</li>
<li><strong>Retry Logic</strong>: The system attempts to resolve transient errors through automated retry mechanisms, ensuring minimal disruption in processing.</li>
<li><strong>Error Queue</strong>: Persistent errors result in the message being moved to an error queue for further analysis or manual intervention.</li>
<li><strong>Auditing and Logging</strong>: The entire process is thoroughly logged, creating an audit trail for compliance purposes. This includes recording each step taken, data changes, processing times, and any errors encountered.</li>
</ul>
<h3 id="outbound-connection"><a class="header" href="#outbound-connection">Outbound Connection</a></h3>
<ul>
<li><strong>Message Dispatch</strong>: Upon successful completion of all workflow steps, the final, processed message is dispatched to one or more outbound systems.</li>
<li><strong>Multiple Destinations</strong>: Destinations can include payment networks, financial institutions, clearinghouses, or other specified endpoints.</li>
<li><strong>Confirmation Handling</strong>: The system may handle acknowledgments or confirmations from the outbound systems, updating the status of the message accordingly.</li>
</ul>
<hr />
<p>This comprehensive process ensures that each payment message is:</p>
<ul>
<li><strong>Accurately Processed</strong>: By following the appropriate workflow tailored to the message’s characteristics.</li>
<li><strong>Enriched and Validated</strong>: Ensuring all necessary information is included and compliant with all relevant regulations.</li>
<li><strong>Correctly Transformed</strong>: Adjusted into the required format for seamless integration with outbound systems.</li>
<li><strong>Reliably Dispatched</strong>: Sent to the correct destinations efficiently and securely.</li>
<li><strong>Fully Audited</strong>: With detailed logs maintained for transparency and regulatory compliance.</li>
</ul>
<hr />
<p>By integrating the Message Processor into your payment infrastructure, you can achieve greater operational efficiency, compliance, and adaptability, positioning your institution at the forefront of modern payment processing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow-processor-overview"><a class="header" href="#workflow-processor-overview">Workflow Processor Overview</a></h1>
<p>This section provides a detailed breakdown of each component in the Workflow Processor, as depicted in the diagram.</p>
<p><img src="message-processor/../assets/workflow-processor.jpeg" alt="Workflow Processor" /></p>
<hr />
<ol>
<li>
<p><strong>Incoming Message Queue</strong></p>
<ul>
<li><strong>Function</strong>: This section represents the queue where incoming payment messages are initially received. Messages from various sources, such as bank APIs or financial gateways, enter the system here.</li>
<li><strong>Role</strong>: The queue buffers messages, ensuring that they are ready for processing by the Workflow Processor without overwhelming the system. This setup supports efficient load balancing and avoids message loss during high traffic periods.</li>
</ul>
</li>
<li>
<p><strong>Rule Engine</strong></p>
<ul>
<li><strong>Function</strong>: The Rule Engine is a key decision-making component within the Workflow Processor. It determines the appropriate workflow for each incoming message.</li>
<li><strong>Workflow Matching</strong>: Based on predefined criteria, such as payment type, originator, region, and other relevant fields, the Rule Engine selects the correct workflow for processing each message. This ensures that messages follow the right path for enrichment, validation, and transformation.</li>
<li><strong>Workflow Metadata Access</strong>: The Rule Engine accesses <strong>Workflow Metadata</strong>, a repository of workflow configurations that define the specific steps required for each type of payment message. This metadata guides the Rule Engine in assigning workflows dynamically based on message characteristics.</li>
</ul>
</li>
<li>
<p><strong>Workflow Execution Steps</strong></p>
<ul>
<li>
<p><strong>Enrichment</strong>:</p>
<ul>
<li><strong>Function</strong>: Enriches the message by adding necessary data, such as customer information, account details, or regulatory compliance data.</li>
<li><strong>Data Sources</strong>: Interacts with external databases or systems (e.g., customer records, compliance checks) through Enrichment Connectors.</li>
</ul>
</li>
<li>
<p><strong>Transformation</strong>:</p>
<ul>
<li><strong>Function</strong>: Converts the message format into the required standard, such as ISO 20022 or SWIFT MT. This ensures compatibility with both internal systems and external networks.</li>
<li><strong>Format Standardization</strong>: Transformation enables the message to meet specific format requirements before routing it to the appropriate destination.</li>
</ul>
</li>
<li>
<p><strong>Validation</strong>:</p>
<ul>
<li><strong>Function</strong>: Validates the message content for accuracy, completeness, and compliance with regulatory and business rules.</li>
<li><strong>Rules</strong>: Validation checks can include data integrity, mandatory fields, format verification, and regulatory compliance to ensure the message meets required standards before dispatch.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Workflow Metadata</strong></p>
<ul>
<li><strong>Purpose</strong>: Workflow Metadata holds configurations for all possible workflows that messages might follow. It contains the logic and steps for handling various types of payment messages.</li>
<li><strong>Structure</strong>: Each workflow configuration (indicated in different colors) is a sequence of processing steps that specify which actions, such as enrichment, transformation, and validation, are needed for a particular message type.</li>
<li><strong>Access by Rule Engine</strong>: The Rule Engine references the Workflow Metadata to determine the appropriate steps to process each message accurately based on the matched workflow.</li>
</ul>
</li>
<li>
<p><strong>Outbound Message Queue</strong></p>
<ul>
<li><strong>Function</strong>: After the message successfully completes all required workflow steps, it is placed into the Outbound Message Queue.</li>
<li><strong>Dispatch</strong>: From here, the message is routed to one or more designated destinations, such as payment networks, financial institutions, or clearinghouses, based on workflow requirements.</li>
<li><strong>Reliability</strong>: The queue provides a buffer for outgoing messages, ensuring smooth dispatch even during high load conditions and facilitating retries if the receiving system is temporarily unavailable.</li>
</ul>
</li>
</ol>
<hr />
<p><strong>Summary</strong>:</p>
<p>This diagram provides a high-level view of the Workflow Processor's internal operations. The process begins with messages entering through the <strong>Incoming Message Queue</strong>. The <strong>Rule Engine</strong> then pulls each message, referencing the <strong>Workflow Metadata</strong> to assign the appropriate workflow. The message then undergoes <strong>Enrichment</strong>, <strong>Transformation</strong>, and <strong>Validation</strong> based on the selected workflow steps. Once processed, the final message is placed into the <strong>Outbound Message Queue</strong> for dispatch to the designated destinations.</p>
<p>The <strong>Workflow Processor</strong> is built to ensure accuracy, efficiency, and compliance in payment processing. By handling each message according to a structured workflow, the system can dynamically adapt to different payment types and regulatory requirements, providing reliable transaction processing across diverse financial networks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="workflow-definition-format-specification"><a class="header" href="#workflow-definition-format-specification">Workflow Definition Format Specification</a></h1>
<p>The Workflow Definition format specifies the structure and sequence of steps required to process a message. Each workflow contains a unique identifier, a version, and a list of sequential steps, where each step has specific actions such as enrichment, validation, transformation, or outbound dispatch. Below is the generic format specification for defining a workflow in JSON.</p>
<hr />
<h3 id="workflow-structure"><a class="header" href="#workflow-structure">Workflow Structure</a></h3>
<pre><code class="language-json">{
    "id": "string",                 // Unique identifier for the workflow.
    "name": "string",               // Descriptive name of the workflow.
    "description": "string",        // Detailed description of what the workflow accomplishes.
    "version": integer,             // Version number of the workflow definition.
    "steps": [                      // List of steps in the workflow.
        {
            "step_id": "string",                   // Unique identifier for the step within the workflow.
            "name": "string",                      // Name of the step.
            "description": "string",               // Description of the step's purpose.
            "type": "string",                      // Type of step (e.g., "enrichment", "validation", "transformation", "outbound").
            
            // For enrichment steps:
            "service": "string",                   // Name of the external service or system used for enrichment.
            "input": {                             // Input fields required by the service.
                "message_field": ["string"]        // List of fields from the message needed for enrichment.
            },
            "output": {                            // Output fields generated by the service.
                "enriched_fields": ["string"]      // List of fields enriched by the service.
            },
            
            // For validation steps:
            "rules": [                             // List of validation rules applied to the message.
                {
                    "rule_id": "string",           // Unique identifier for the rule.
                    "field": "string",             // Message field to validate.
                    "condition": "string",         // Validation condition (e.g., "not_null", "equals").
                    "value": "string (optional)",  // Expected value for conditions like "equals".
                    "error_message": "string"      // Error message to return if validation fails.
                }
            ],

            // For transformation steps:
            "input_format": "string",              // Format of the message before transformation.
            "output_format": "string",             // Desired format of the message after transformation.
            "output_type": "string",               // Specific type/version of the output format.

            // For outbound dispatch steps:
            "connection": "string",                // Name of the outbound connection.
            "retry_policy": {                      // Configuration for retrying failed dispatch attempts.
                "max_retries": integer,            // Maximum number of retry attempts.
                "retry_interval": "string"         // Interval between retries (e.g., "30s").
            }
        }
    ]
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="technical-architecture-and-components"><a class="header" href="#technical-architecture-and-components">Technical Architecture and Components</a></h2>
<p>The Message Processor’s architecture is designed for high scalability, reliability, and efficiency in processing large volumes of transactions. It integrates several key technical components that work together to manage inbound and outbound connections, handle data storage, and ensure smooth workflow execution. Here’s an overview of the core components:</p>
<p><img src="message-processor/../assets/technical-architecture.jpeg" alt="Technical architecture" /></p>
<ul>
<li>
<p><strong>Integration System (Inbound/Outbound Connection)</strong>: The integration layer connects the system with external messaging and event platforms such as <strong>Kafka</strong>, <strong>Pulsar</strong>, <strong>Amazon SQS</strong>, <strong>Google Cloud Pub/Sub</strong>, and <strong>Azure Event Hub</strong>. This layer manages the flow of messages in and out of the system, ensuring reliable communication with various endpoints.</p>
</li>
<li>
<p><strong>Data Storage (MongoDB)</strong>: MongoDB is used to store essential data, including <strong>Workflow Metadata</strong>, <strong>Enrichment Data</strong>, and <strong>Transaction Data</strong>. Workflow metadata defines the steps and logic for each workflow, enrichment data adds necessary context to each message, and transaction data records details of each processed message.</p>
</li>
<li>
<p><strong>Cache Layer (Redis)</strong>: Redis is employed as a caching layer to improve processing speed and handle temporary data. It is also used for <strong>concurrency control</strong>, ensuring that only one instance of the workflow processes a specific message at any time, avoiding duplication and race conditions.</p>
</li>
<li>
<p><strong>Workflow Engine</strong>: The core processing engine executes the workflows defined in the Workflow Metadata. It pulls data from MongoDB and utilizes Redis for concurrency locks, ensuring efficient, accurate, and sequential message processing according to defined rules.</p>
</li>
</ul>
<p>This architecture ensures that messages are processed in a highly controlled and efficient manner, supporting large-scale and real-time transaction processing.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-structure"><a class="header" href="#message-structure">Message Structure</a></h1>
<p>The Message Structure defines the JSON format used by the Open Payments system to handle incoming messages. This structure is <strong>generic</strong> and can adapt to various standards depending on the domain of use.</p>
<p>When the Message Processor is used for payment-related messages, <strong>ISO 20022</strong> is used as the standard within the <code>data</code> section. However, if the processor is used in other systems, this structure can accommodate other standardized formats in the <code>data</code> section, making it flexible for multiple use cases.</p>
<p>The <strong>root-level fields</strong> contain essential attributes that the message processing product understands. Domain-specific data is encapsulated within the <code>metadata</code> and <code>data</code> sections, which the workflows interpret and act upon as needed.</p>
<h2 id="schema-definition"><a class="header" href="#schema-definition">Schema Definition</a></h2>
<pre><code class="language-json">{
    "id": "string",                   // Unique identifier for the message, generated by the message processing system.

    "payload": "string",              // Original incoming message in its raw form; kept unaltered for reference and traceability.

    "tenant": "string",               // Identifier for the tenant (useful in multi-tenant setups for isolating data).

    "origin": "string",               // Source or origin of the message (e.g., system/channel name).

    "data": {                         // Contains domain-specific data; ISO20022-compliant for payments, or another standard as applicable.
        // Fields specific to the chosen standard (e.g., ISO20022 fields for payments, or other standard-compliant fields for different domains).
    },

    "status": "string",               // Current status of the message in the processing pipeline (e.g., "pending", "processed", "failed").

    "retries": integer,               // Count of retry attempts if processing encountered an error.

    "metadata": {                     // Contains domain-specific metadata and contextual information.
        "format_version": "string",   // Version of the data format used in the `data` object (e.g., "ISO20022:v1").
        "type": "string",             // Type of message (e.g., payment type, transaction category), understood by the workflow.
        "priority": "string",         // Optional priority level for processing (e.g., "real-time", "queued", "scheduled").
        "tags": ["string"],           // Optional tags for categorization (e.g., ["international", "urgent"]).
        "flags": {                    // Flags or indicators for special handling, as per domain needs.
            "requires_urgent_review": true
        }
        // Additional contextual fields relevant to the workflow can be added here.
    },

    "auditlog": [                     // Array of audit log entries, recording each action taken on the message.
        {
            "timestamp": "string",    // Timestamp of when the action occurred.
            "hash": "string",         // Hash of the message state at this step, for integrity verification.
            "workflow": "string",     // Workflow name or identifier associated with this action.
            "task": "string",         // Task or step within the workflow (e.g., "enrichment", "validation").
            "description": "string",  // Description of the action performed at this step.
            "instance": "string"      // Instance ID of the service handling this action (useful in distributed environments).
        } 
    ]
}
</code></pre>
<h2 id="example-message-object"><a class="header" href="#example-message-object">Example Message Object</a></h2>
<p>Here’s an example JSON object that illustrates how this structure can be populated for a payment-related use case:</p>
<pre><code class="language-json">{
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "payload": "&lt;originalMessage&gt;...&lt;/originalMessage&gt;",
    "tenant": "tenant_ABC",
    "origin": "banking_gateway_A",
    
    "data": {
        "transaction_id": "TX123456789",
        "amount": "1000.00",
        "currency": "USD",
        "sender_details": {
            "name": "John Doe",
            "account": "1234567890"
        },
        "receiver_details": {
            "name": "Jane Smith",
            "account": "0987654321"
        }
    },
    
    "status": "pending",
    "retries": 1,
    
    "metadata": {
        "format_version": "ISO20022:v1",
        "type": "credit_transfer",
        "priority": "real-time",
        "tags": ["international", "urgent"],
        "flags": {
            "requires_urgent_review": true
        }
    },
    
    "auditlog": [
        {
            "timestamp": "2023-10-27T10:15:30Z",
            "hash": "9a6b91d2e5e6c4d59b78ecbb1f9f6c88",
            "workflow": "credit_transfer_workflow",
            "task": "initial_validation",
            "description": "Validated incoming message structure",
            "instance": "instance_001"
        },
        {
            "timestamp": "2023-10-27T10:16:30Z",
            "hash": "c5d8b3e80b3d4aefc567a5ed9306a6d3",
            "workflow": "credit_transfer_workflow",
            "task": "enrichment",
            "description": "Enriched with customer account details",
            "instance": "instance_002"
        }
    ]
}
</code></pre>
<p>This Message Structure is designed to be adaptable across different domains, ensuring compliance with specific standards like ISO20022 for payments, while providing the flexibility to incorporate other formats as needed. By maintaining a clear separation between product-specific fields and domain-specific data, this structure supports multi-tenant, multi-domain use cases effectively within the Open Payments platform.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-and-auditing-details"><a class="header" href="#error-handling-and-auditing-details">Error Handling and Auditing Details</a></h1>
<ul>
<li><strong>Retry Logic</strong>: Automatically retries processing steps that fail due to transient issues (e.g., temporary network outages, momentary service unavailability).</li>
<li><strong>Error Queue</strong>: A holding area for messages that cannot be processed after retries, allowing for manual review and intervention.</li>
<li><strong>Auditing</strong>: Every action taken on the message is logged, including timestamps, processing steps completed, errors encountered, data transformations applied, and user interventions if any.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-strengths"><a class="header" href="#core-strengths">Core Strengths</a></h1>
<p>By following this structured approach, the Message Processor ensures that payment messages are handled efficiently, accurately, and securely. The system's design allows for high scalability and fault tolerance, enabling it to process large volumes of transactions while maintaining reliability. This is achieved through:</p>
<ul>
<li><strong>Horizontal Scalability</strong>: The architecture supports scaling out by adding more processing units to handle increased loads.</li>
<li><strong>Fault Tolerance</strong>: Redundant systems and automated failover mechanisms ensure continuous operation even in the event of component failures.</li>
<li><strong>Distributed Processing</strong>: Workloads are balanced across multiple processors, optimizing performance and resource utilization.</li>
</ul>
<p>This workflow not only improves operational efficiency but also enhances compliance and risk management through robust error handling and comprehensive logging. It provides financial institutions with the flexibility to adapt to new payment types, regulatory changes, and technological advancements, ensuring seamless interoperability across various platforms.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages-library"><a class="header" href="#messages-library">Messages Library</a></h1>
<p>The library provides tools for parsing, validating, and transforming financial messages, with support for ISO 20022 and FedNow message formats. The library is designed to help developers integrate financial message handling into their Rust applications, using serde for (de)serialization.</p>
<hr />
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><strong>ISO 20022 Support</strong>: Comprehensive support for key ISO 20022 payment message types.</li>
<li><strong>FedNow Message</strong>: Full support for FedNow message formats.</li>
<li><strong>(De)serialization</strong>: Using serde for easy conversion between XML and JSON.</li>
<li><strong>Extensibility</strong>: Easily extendable to support additional message types or custom formats.</li>
</ul>
<h3 id="supported-messages"><a class="header" href="#supported-messages">Supported Messages</a></h3>
<p>The library supports a variety of financial message formats from both ISO 20022 and FedNow, covering key areas of the payment lifecycle.</p>
<h4 id="iso-20022-messages"><a class="header" href="#iso-20022-messages">ISO 20022 Messages</a></h4>
<ul>
<li><strong>pacs</strong>: Payment Clearing and Settlement</li>
<li><strong>pain</strong>: Payment Initiation</li>
<li><strong>admi</strong>: Administrative messages</li>
<li><strong>auth</strong>: Authorization messages</li>
<li><strong>camt</strong>: Cash Management</li>
<li><strong>reda</strong>: Reference Data</li>
<li><strong>remt</strong>: Remittance Advice</li>
<li><strong>acmt</strong>: Account Management</li>
<li><strong>head</strong>: Header messages</li>
</ul>
<h4 id="fednow-messages"><a class="header" href="#fednow-messages">FedNow Messages</a></h4>
<ul>
<li><strong>Customer Credit Transfer</strong></li>
<li><strong>Payment Status Report</strong></li>
<li><strong>Payment Return</strong></li>
</ul>
<hr />
<p>This extensive support for ISO 20022 messages enables comprehensive coverage of the payment message lifecycle, including administrative processes, investigations, status reports, and transaction instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<p>You’ll need the following installed to build and use this library:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust</a> (latest stable version)</li>
<li><a href="https://doc.rust-lang.org/cargo/getting-started/installation.html">Cargo</a> (Rust package manager)</li>
</ul>
<h3 id="installation"><a class="header" href="#installation">Installation</a></h3>
<p>Add the following to your <code>Cargo.toml</code> to start using the library in your Rust project:</p>
<pre><code class="language-toml">[dependencies]
# This dependency includes support for the entire ISO 20022 message formats.
# The "payments" feature enables various ISO 20022 message categories, such as pacs, pain, camt, etc.
# If you only need specific message types, you can enable just those features (e.g., "pacs", "pain").
open-payments-iso20022 = { version = "1.0.1", features = ["payments"] }

# This dependency provides support for the FedNow message formats.
# You get full support for parsing and serializing FedNow messages out of the box.
open-payments-fednow = "1.0.1"
</code></pre>
<h3 id="features-1"><a class="header" href="#features-1">Features</a></h3>
<p>The ISO20022 message library <code>open-payments-iso20022</code> provides several features to allow you to include only the message types relevant to your use case. Here’s a breakdown of the available features:</p>
<pre><code class="language-toml">[features]
default = ["head"]  # Default feature, includes the basic header message.
iso20022 = ["payments"]  # Enables all payment-related ISO 20022 messages.
payments = ["acmt", "admi", "auth", "camt", "head", "pacs", "pain", "reda", "remt"]  # Includes all payments-related ISO 20022 message types.

# Individual ISO 20022 message modules:
acmt = ["open-payments-iso20022-acmt"]  # Account Management messages
admi = ["open-payments-iso20022-admi"]  # Administrative messages
auth = ["open-payments-iso20022-auth"]  # Authorization messages
camt = ["open-payments-iso20022-camt"]  # Cash Management messages
head = ["open-payments-iso20022-head"]  # Basic Header messages (default)
pacs = ["open-payments-iso20022-pacs"]  # Payment Clearing and Settlement messages
pain = ["open-payments-iso20022-pain"]  # Payment Initiation messages
reda = ["open-payments-iso20022-reda"]  # Reference Data messages
remt = ["open-payments-iso20022-remt"]  # Remittance Advice messages
</code></pre>
<p>By configuring the features, you can optimize the library for your specific message requirements, minimizing unnecessary dependencies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p><strong>Example: Creating an ISO 20022 Message Object</strong></p>
<pre><code class="language-rust noplayground">use open_payments_iso20022::document::Document;
use open_payments_iso20022_admi::admi_002_001_01::Admi00200101;

fn main() {
    let doc = Document::Admi00200101(Box::new(Admi00200101::default()));

    println!("{:?}", doc)
}</code></pre>
<p><strong>Example: Creating a FedNow Message Object</strong></p>
<p>Similarly, here’s an example of how to create a FedNow message object:</p>
<pre><code class="language-rust noplayground">use open_payments_fednow::document::Document;
use open_payments_fednow::iso::pacs_008_001_08::FIToFICustomerCreditTransferV08;

fn main() {
    let doc = Document::FIToFICustomerCreditTransferV08(Box::new(FIToFICustomerCreditTransferV08::default()));

    println!("{:?}", doc)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="messages-api"><a class="header" href="#messages-api">Messages API</a></h1>
<p>The Messages API is designed to parse and validate financial payment messages. This API supports the FedNow &amp; ISO20022 format, applying validation rules from the official XSD schema files. The API is available for both public and private use, with a ready-to-deploy Docker image available on Docker Hub.</p>
<ul>
<li><strong>Repository</strong>: <a href="https://github.com/Open-Payments/messages-api">Open Payments Messages API</a></li>
<li><strong>Docker Hub</strong>: <a href="https://hub.docker.com/r/harishankarn/payment-messages-api">Payment Messages API Docker Image</a></li>
<li><strong>API Documentation</strong>: <a href="https://www.postman.com/openpaymentsapi/open-payments/overview">Postman Collection</a></li>
</ul>
<hr />
<h2 id="api-endpoint"><a class="header" href="#api-endpoint">API Endpoint:</a></h2>
<p><code>POST /validate</code></p>
<h2 id="description"><a class="header" href="#description">Description:</a></h2>
<p>This endpoint accepts an XML payment message, identifies the message format (e.g., pacs.008, pacs.009), and performs the following actions:</p>
<ol>
<li><strong>Parsing</strong>: Converts the XML payment message into an internal object model.</li>
<li><strong>Validation</strong>: Applies schema-based validation using the FedNow XSD files.</li>
<li><strong>Response</strong>: Converts the parsed message into a JSON object and returns it as the API response.</li>
</ol>
<hr />
<h4 id="additional-features"><a class="header" href="#additional-features"><strong>Additional Features:</strong></a></h4>
<ul>
<li><strong>Automatic Format Detection</strong>: The API identifies the message type automatically, so no need to specify the format in the request.</li>
<li><strong>XSD Validation</strong>: Applies validation rules as defined by the FedNow XSD files.</li>
<li><strong>JSON Conversion</strong>: Converts valid XML messages to JSON format, making it easier to consume by modern applications.</li>
</ul>
<hr />
<h3 id="api-documentation-and-try-out"><a class="header" href="#api-documentation-and-try-out">API Documentation and Try Out</a></h3>
<p>Explore the full API documentation and <strong>try out the Validate API</strong> using the Postman Collection. Postman allows you to test the API directly in your browser:</p>
<ul>
<li><strong>Postman Collection</strong>: <a href="https://www.postman.com/openpaymentsapi/open-payments/overview">Open Payments Postman Collection</a></li>
<li><strong>Try it out</strong>: You can use Postman’s “Run in Postman” button to directly test the API instance and see how it works with real data.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-1"><a class="header" href="#installation-1">Installation</a></h1>
<h2 id="running-a-local-instance"><a class="header" href="#running-a-local-instance">Running a Local Instance:</a></h2>
<p>To run your own private instance of the Validate API, you can use the Docker image from Docker Hub:</p>
<h3 id="step-1-pull-the-docker-image"><a class="header" href="#step-1-pull-the-docker-image">Step 1: Pull the Docker Image</a></h3>
<pre><code class="language-bash">docker pull harishankarn/payment-messages-api
</code></pre>
<h3 id="step-2-run-the-docker-container"><a class="header" href="#step-2-run-the-docker-container">Step 2: Run the Docker Container</a></h3>
<pre><code class="language-bash">docker run -p 8080:8080 harishankarn/payment-messages-api
</code></pre>
<p>This will start the API on port <code>8080</code> of your local machine. You can then make POST requests to <code>http://localhost:8080/validate</code>.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-1"><a class="header" href="#usage-1">Usage</a></h1>
<h2 id="request"><a class="header" href="#request">Request:</a></h2>
<ul>
<li><strong>Method</strong>: <code>POST</code></li>
<li><strong>Content-Type</strong>: <code>application/xml</code></li>
<li><strong>Body</strong>: The XML content of the payment message (e.g., pacs.008, pacs.002, etc.).</li>
</ul>
<h3 id="example-request"><a class="header" href="#example-request">Example Request:</a></h3>
<pre><code class="language-xml">&lt;FIToFICstmrCdtTrf&gt;
  &lt;!-- Example XML content based on FedNow ISO20022 format --&gt;
&lt;/FIToFICstmrCdtTrf&gt;
</code></pre>
<hr />
<h2 id="response"><a class="header" href="#response">Response:</a></h2>
<ul>
<li><strong>Content-Type</strong>: <code>application/json</code></li>
<li><strong>Body</strong>: The parsed payment message in JSON format, with details of the validation status.</li>
</ul>
<h3 id="example-successful-response"><a class="header" href="#example-successful-response">Example Successful Response:</a></h3>
<pre><code class="language-json">{
  "status": "success",
  "message": {
    "FIToFICstmrCdtTrf": {
      "GrpHdr": {
        "MsgId": "ABC123456",
        "CreDtTm": "2024-10-01T12:00:00Z"
      },
      ...
    }
  }
}
</code></pre>
<h3 id="example-validation-error-response"><a class="header" href="#example-validation-error-response">Example Validation Error Response:</a></h3>
<pre><code class="language-json">{
  "status": "error",
  "errors": [
    {
      "field": "GrpHdr.MsgId",
      "message": "Message ID is missing or invalid"
    }
  ]
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-transformation-library"><a class="header" href="#message-transformation-library">Message Transformation Library</a></h1>
<p>Coming Soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-2"><a class="header" href="#installation-2">Installation</a></h1>
<p>Coming Soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-2"><a class="header" href="#usage-2">Usage</a></h1>
<p>Coming Soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="samplify-library"><a class="header" href="#samplify-library">Samplify Library</a></h1>
<p><em><strong>A Powerful and Flexible Sample Data Generator for Rust</strong></em></p>
<p><strong>samplify-rs</strong> is a Rust library designed to simplify the process of generating sample data for testing, prototyping, and development purposes. Leveraging Rust’s powerful procedural macros and conditional compilation features, samplify-rs allows you to automatically generate realistic and customizable sample instances of your data structures without polluting your production code.</p>
<h2 id="features-2"><a class="header" href="#features-2">Features</a></h2>
<ul>
<li><strong>Automatic Derivation</strong>: Use the Sampleable derive macro to automatically implement sample generation for your structs and enums.</li>
<li><strong>Field-Level Customization</strong>: Annotate your fields with attributes to specify value ranges, patterns, choices, lengths, and inclusion probabilities.</li>
<li><strong>Support for Complex Structures</strong>: Handle deeply nested and complex data structures with optional fields and variations effortlessly.</li>
<li><strong>Conditional Compilation</strong>: Enable or disable sample generation code using a feature flag, keeping your production builds clean and efficient.</li>
<li><strong>Extensibility</strong>: Easily integrate with existing projects and extend functionality without modifying original data structures.</li>
</ul>
<h2 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h2>
<ul>
<li><strong>Non-Intrusive</strong>: Does not require modification of your production codebase; sample code is conditionally compiled.</li>
<li><strong>Customizable Data Generation</strong>: Fine-tune how sample data is generated for each field.</li>
<li><strong>Improved Testing</strong>: Quickly generate realistic test data to enhance your testing processes.</li>
<li><strong>Lightweight</strong>: Excludes sample generation code from production builds, ensuring optimal performance and binary size.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-3"><a class="header" href="#installation-3">Installation</a></h1>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p><strong>Add samplify-rs to Your Project</strong></p>
<p>Add the following to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies]
samplify-rs = "0.1.0"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-3"><a class="header" href="#usage-3">Usage</a></h1>
<ol>
<li><strong>Include the macro in your code</strong></li>
</ol>
<pre><code class="language-rust noplayground">use samplify_rs::Sampleable;</code></pre>
<ol start="2">
<li><strong>Annotate Your Data Structures</strong></li>
</ol>
<p>Use <code>#[cfg_attr(feature = "sample", derive(Sampleable))]</code> on your structs and enums.</p>
<pre><code class="language-rust noplayground">#[derive(Debug, Serialize, Deserialize)]
#[cfg_attr(feature = "sample", derive(Sampleable))]
struct PaymentInstruction {
    currency: String,
    amount: f64,
}</code></pre>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-rust noplayground">use samplify_rs::Sampleable;
use serde::{Deserialize, Serialize};
use serde_json;

#[derive(Debug, Serialize, Deserialize, Sampleable)]
struct PaymentInstruction {
    currency: String,
    amount: f64,
}

fn main() -&gt; Result&lt;(), String&gt; {
    let config_json = r#"
    {
        "amount": [10.0, 1000.0],
        "currency": ["USD", "EUR", "GBP"]
    }
    "#;
    let config_map: serde_json::Map&lt;String, serde_json::Value&gt; = serde_json::from_str(config_json).map_err(|e| e.to_string())?;
    let sample_payment = PaymentInstruction::sample(&amp;config_map)?;

    println!("{:?}", sample_payment);

    Ok(())
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-involved"><a class="header" href="#get-involved">Get Involved</a></h1>
<p>Open Payments is an inclusive project that welcomes contributions from developers, architects, financial institutions, and others passionate about the future of payments. Join us in reshaping how payments are processed and setting a new standard for financial interoperability.</p>
<p>Explore our repositories and start building with <a href="https://github.com/orgs/Open-Payments/repositories">Open Payments!</a> Together, let’s advance the future of financial technology.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="license"><a class="header" href="#license">License</a></h1>
<p>Open Payments is released under the Apache License 2.0, a permissive open-source license that allows for wide usage, modification, and distribution of the project. This license provides users with flexibility while requiring preservation of the license notice and disclaimers in derivative works.</p>
<p>The Apache 2.0 License allows developers, financial institutions, and other users to freely use, modify, and share Open Payments, while maintaining compliance with the terms of the license. Contributions from the community are welcome to improve and expand Open Payments. By contributing to the project, you agree that your contributions will be licensed under the same Apache 2.0 License.</p>
<p>For further details, please refer to the LICENSE file in our <a href="https://github.com/orgs/Open-Payments/repositories">GitHub repositories</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="get-in-touch-with-the-open-payments-team"><a class="header" href="#get-in-touch-with-the-open-payments-team">Get in Touch with the Open Payments Team!</a></h1>
<p>Whether you’re exploring Open Payments for your projects, have questions about our open-source platform, or just want to say hello, we’d love to hear from you!</p>
<p><strong>Email Us:</strong> Reach out to our team at <strong><a href="mailto:team@openpayments.tech">team@openpayments.tech</a></strong>, and we’ll be sure to get back to you as soon as possible.</p>
<p>Our inbox is open for:</p>
<ul>
<li><strong>Feedback &amp; Ideas</strong>: Tell us what you’d like to see or share insights on how you’re using Open Payments.</li>
<li><strong>Technical Support</strong>: Got a question or need a bit of guidance? We’re here to help!</li>
<li><strong>Partnership Inquiries</strong>: Interested in working together? Let’s discuss how we can collaborate.</li>
</ul>
<p>Feel free to reach out—we’re always excited to connect with users, developers, and anyone passionate about payment solutions. Together, let’s make Open Payments better!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
